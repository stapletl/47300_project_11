
This problem generator defines the problem distribution for our Sokoban solver competition.  You DON'T NEED TO USE IT to participate well.  I have included with it TWENTY problems generated by it, in two sets of ten, that may well suffice for your evaluations.  We will use mostly (probably entirely) problems generated by this generator to compare competition entries. 

======if you wish to just use the twenty problems included with this, for your evaluation, you can ignore the rest of this file=========

This code works pretty hard to try to generate an interesting Sokoban level, and is based largely on a grad student project by Olivier Lemer, in Europe, a few years ago called "Sokogen".  You can track it down easily with web search.  There are many other level generators, and probably many better ones, but I wanted one in Python.

I don't even understand how it works, so all credit goes to the Sokogen author, I have just evaluated the resulting levels and found they do a pretty good job of differentiating the automated techniques that we have tried in ECE 473.

I have made a few modifications to make it usable for us; most especially the output format now matches our class format.  I added the command line interface.

LEVEL GENERATION IS QUITE SLOW AND RESOURCE INTENSIVE, and attempts to generate more than a couple levels in one invocation have not been that reliable on my Linux laptop, twice crashing it completely somehow.  I recommend generating one or two levels at a time.  Also, I have not tried generating larger levels than those in the default settings and I suspect it may not be well tuned to do that.

You don't need to generate new levels to work on this problem. I have provided twenty levels generated by this generator, and we will test against something like twenty more hidden levels.  But if you want to have more, here is a place to get them

--Bob Givan


Here are the creator's implementation notes:

# SokoGen

**SokoGen** is a project in which I wish to generate interesting Sokoban levels automatically. The goal is to avoid brute force (and by that I mean strategies that will generate random, potentially unsolvable levels and then try to see how fast they can be solved, if at all), and prefer a "constructive" approach.

## How it works
This algorithm is based on the work of Bilal Kartal, Nick Sohre, and Stephen J. Guy in their paper [*Data-Driven Sokoban Puzzle Generation with Monte Carlo Tree Search*](https://www.researchgate.net/publication/311706278_Data-Driven_Sokoban_Puzzle_Generation_with_Monte_Carlo_Tree_Search). **SokoGen** uses a similar strategy in which a board is built from scratch using a Monte Carlo Tree Search algorithm. However it differs in how a state is represented, in a way that allows for much better efficiency.

The key point is that I do not give the player an actual position nor the ability to move. Representing the player as a specific position comes with two main drawbacks. The first is that, on average, it favors pushing boxes that are closest to the player since moving all the way to the other side of the board to push another box is less likely to happen, which results in levels that can often be solved by following a boring "push the box that's next to you" strategy. The second, much more important point, relates to space and time complexity. If each move of the player counts as a node in the tree, it will grow much faster, take up more space, and require more time to traverse. Those are the reasons why the player is represented as a *set* of positions rather than a single point, which correspond to all the positions in which the player could move to without making an impact on the board. Note that here "making an impact" means pushing any box, but could ideally be made even broader (see Improvements). This allows to reduce the height of the tree by a non-negligible factor, which has resulted in much better and faster results.

## Implementation Details
The traversal of the tree is done in a way that reduces the number of object creation/allocation and copy as much as possible, and all modifications are done in-place. There is however still a lot of optimizations to be done in this area. Additionally, the evaluation score is already partially computed before the *Evaluate* state is even reached. This avoids some polynomial-time computations in the evaluation function that can be done iteratively during the tree construction. This means that the steps of those computations are distributed on the entire path to the final leaf node, which thus allows us to avoid re-computing the whole first part of it every time.

## Improvements
The main improvement I wish to work on in the future is the boxes' representation. I believe that using a representation similar to that of the player could again compress the tree even further, avoid useless "back-and-forth" box pushes, and improve not only time and space complexity but also overall quality of generated levels.
